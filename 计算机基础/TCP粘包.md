# TCP粘包

TCP是面向流的协议，**封装了下层一个一个的TCP报文，通过序列号、滑动窗口、重传机制等，保障有序，不丢失，给上层用户暴露有序的字节流**，所以**TCP根本没有粘包问题**  

## 那么面试时，面试官说的粘包问题是什么呢？  

其实原因有两个：  

第一个是因为TCP的字节是流式发送的，面向流的协议，**TCP不会按照开发者的期望，保持send输入的数据的边界，导致接收侧可能一下子收到多个应用层报文，需要接收开发者自己分开**。其实这时TCP本身的属性，并非是问题，但是有些水平较差的开发者觉得这样是不合理的，救起了个名字叫做”粘包问题“  

第二个是指，当程序员想要通过TCP发送小尺寸数据时，**开启了Nagle算法的TCP不会直接发送，而会等待多个小TCP报文，封装在一个TCP报文中来发送**，节省发送TCP报文头的开销。于是，先被send的数据可能需要等待一段时间，才能跟后面被send的数据一起组成报文发出去。这种“粘包”也不是问题，是因为TCP希望节约网络资源而已。

那么这样看上去，“TCP粘包”这个词绝对是错误的，不应该出现的。应该叫做，如何合理设计应用层协议，来拆分TCP字节流的问题。  

## 如何合理涉及应用层协议来拆分TCP字节流呢？

第一种“粘包”，靠**设计一个带包头的应用层报文结构**就能解决。包头定长，以特定标志开头，里带着负载长度，这样接收侧只要以定长尝试读取包头，再按照包头里的负载长度读取负载就行了，多出来的数据都留在缓冲区里即可。  

  

第二种“粘包”，设置TCP_NODELAY就能屏蔽Nagle算法，但你最好确定自己知道自己在干什么。  