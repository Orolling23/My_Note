# Mysql,InnoDB引擎
https://www.cnblogs.com/crazylqy/p/7611069.html

## MySQL基础架构

![MySQL架构](./Pics/MySQL架构.jpg)  

* 连接器：身份认证和权限相关
* 查询缓存：执行查询语句的时候，会先查查询缓存（8.0版本之后移除，原因是这个功能不太实用）
* 分析器：如果没有命中缓存，SQL语句会经过分析器，进行**词法分析和语法分析**，看看你的SQL语句要干嘛，检查语法是否正确
* 优化器：按照MySQL认为**最优的方案去执行**。如何选择索引，多表查询时如何选择关联顺序等。
* 执行器：**执行语句，从存储引擎返回数据**

简单来说：

* Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
* 存储引擎：主要负责数据的存储和读取，可替换插件式架构。支持InnoDB、MyISAM等多个存储引擎。

## InnoDB概述

InnoDB适用于OLTP（小型读多，写少）应用，且具有**事务性和行级锁**  

MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，**但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复**。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。

### InnoDB和MyISAM对比
两者的对比：
1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而**InnoDB 支持行级锁(row-level locking)和表级锁**,默认为行级锁。
2. **是否支持事务和崩溃后的安全恢复**： MyISAM 强调的是性能（但很多情况下并没有InnoDB快），每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持，外部键等高级数据库功能。 **具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表**。
3. **是否支持外键**： MyISAM不支持，而InnoDB支持。
4. **是否支持MVCC**：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。
5. **索引**：MyISAM和InnoDB都时可以使用B+树，**但MyISAM的B+树叶节点的data域存放的是数据记录的地址**，“非聚簇索引”，数据文件和索引文件分离；InnoDB数据文件本身就是索引文件，再根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
## 索引
索引说白了就是数据组织的结构，用什么数据结构组织数据，对应查询和插入就有什么样的特性。  

MySQL索引使用的数据结构主要有**BTree索引 和 哈希索引 **。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引，数据结构是B+树。  

### B+树
B+树由B树和索引顺序访问方法（ISAM）演化而来，是一棵经典的平衡查找树。  

B+树中所有记录节点都是**按键值大小顺序**存放在**同一层的叶子节点**上，各叶子节点**由双向指针连接**。   

B+树的插入、删除操作这里不详细写  

### InnoDB中的B+树索引
MySQL中，B+树的高度一般都在2~4层，意味着查找某一键值的行记录只需要2~4次IO。B+树索引分为**聚集索引和辅助索引**，内部都是高度平衡的B+树，其二者的不同在于，**聚集索引的叶子节点存放的是一整行的信息，而辅助索引的叶子节点存放的是键值和一个书签，书签是主键索引**
### 聚集索引
聚集索引就是按照每张表的**主键**构造一棵B+树，**同时叶子节点中存放的即为整张表的行记录**，也将聚集索引的叶子节点称为数据页（默认大小16KB）。每个数据页通过**双向链表**连接。  

每张表只能有一个聚集索引， 多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引可以直接获取整行数据。另外，由于定义了数据的逻辑顺序，聚集索引能够特别快的访问对范围值的查询。  

聚集索引对于**主键的排序查找和范围查找速度非常快**。对于OLTP应用，每次在数据库中查询一小部分，但经常查询，B+树索引的建立意义非常大。  

而对于OLAP应用，经常进行表扫描，统计，访问大量数据，对于多张表的连接，建立索引也还是有意义的。  

**注意只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。**

### 辅助索引
辅助索引也叫非聚集索引，**叶子节点并不包含行记录的所有数据**。除了包含键值以外，还包含一个**书签，对应的是聚集索引键**。每张表可以有多个辅助索引，当通过辅助索引来搜索数据时，InnoDB引擎会遍历辅助索引并获得指向主键索引的主键，再通过主键索引来找到完整的行记录。
### 联合索引
指对表上的多个列进行索引。联合索引可以是主键索引或者辅助索引。  

联合索引的使用有**最左前缀匹配原则**：使用联合索引查询时，MySQL会一直向右匹配直到遇到范围查询(> < between like)就停止匹配。  

另外在联合索引设计有一条经验，**唯一值多选择性好的列作为复合索引的前导列**，这里唯一值多，比如性别唯一值由男和女，唯一值比较少，而create_time每一秒都是唯一值，唯一值多。**但是这个经验只适合于等值条件过滤，不适合有范围条件过滤的情况**。  

例子见此公众号：https://mp.weixin.qq.com/s/fShA7jxjshKyHEHfVDrLVA

### 覆盖索引
覆盖索引并不是一种索引，它是指**从辅助索引就可以查到需要的数据，而不需要查询聚集索引**，可以减少大量IO操作。  
* 联合索引和覆盖索引结合使用可以对多个查询条件的查询进行匹配，比如分页查询。  

表trade_info，表上有索引idx_status_create_time(status,create_time)，由于叶子节点包含主键，也就等价于idx_status_create_time(status,create_time,id)。**对于典型的分页limit m, n来说，越往后翻页越慢，也就是m越大会越慢，因为要定位m位置需要扫描的数据越来越多，导致IO开销比较大**。以下是原查询SQL  
```
select  * from trade_info where status = 0 and create_time >= '2020-10-01 00:00:00' and create_time <= '2020-10-07 23:59:59' order by id desc limit 102120, 20;
```
这里可以利用辅助索引的覆盖扫描来进行优化，**利用子查询先获取id，这一步就是索引覆盖扫描，不需要回表，然后通过id跟原表trade_info进行关联**，改写后的SQL如下：  
```
select * from trade_info a ,

(select  id from trade_info where status = 0 and create_time >= '2020-10-01 00:00:00' and create_time <= '2020-10-07 23:59:59' order by id desc limit 102120, 20) as b   //这一步走的是索引覆盖扫描，不需要回表

 where a.id = b.id;
```
其中也利用了**分而治之**的思想。  
### 哈希索引
InnoDB中的哈希索引采取除法散列方式，冲突机制采用链表方式。  

InnoDB中的缓冲池使用了哈希索引，对数据页缓存在缓冲池中

## 锁
按照锁的粒度分类，数据库锁分为**表级锁和行级锁**。  
* MyISAM采用表级锁(table-level locking)。
* InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
行级锁进一步可以分类为共享锁 S Lock 和 排他锁 X Lock。  
### 意向锁
InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上的加锁，InnoDB提供了额外的意向锁机制。意向锁将加锁分为多个层次，**加意向锁意味着事务希望在更细的粒度上加锁**    

InnoDB中，意向锁比较简练，意向锁即为表级别的锁，设计目的主要是在一个事务中揭示下一行将请求的锁类型。其支持两种意向锁：意向共享锁 IS Lock和意向排他锁 IX Lock；分别表示事务想要获得表中一行或者多行的共享锁/排他锁  

**简言之：意向锁只是一种状态，标记了该表中是否有数据已经被其他事务加了共享锁或者排他锁，来减少其他事务加锁时，扫描全表检查锁状态的开销**  

### 多版本并发控制MVCC
指的是一种提高并发的技术，可以理解为行级锁的变种。InnoDB中的实现方式是在**Undo Log**中可以找到数据的历史版本，目的是：**通过历史版本的数据提供给用户*读*（不同的隔离级别可以看到不同版本的历史数据，有些老，有些新），来实现读读并发、读写并发。**  
* **MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作**。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。**而 SERIALIZABLE 则会对所有读取的行都加锁**。
* 而InnoDB中RR级别下实现MVCC的方式是:
	1. 事务以排他锁的形式修改原始数据
	2. 把修改前的数据存放于undo log，通过数据表中的隐式字段DB_ROLL_PTR回滚指针与主数据关联，同时undo log中的数据行的回滚指针会指向更早的数据，形成**数据链**
	3. 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）
### 一致性非锁定读
指InnoDB引擎利用MVCC来读取当前执行时间数据库中行的数据，如果被读取的行正在被DELETE或者UPDATE，**读取操作不会等待X锁的释放，而会区读取行的一个快照数据，通过Undo Log实现**。  

非锁定读极大的提高了数据库的并发性，**是默认的读取方式**，在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下，InnoDB使用一致性非锁定读。在 READ COMMITTED 级别下，总是读取被锁定行的**最新一份**快照数据；REPEATABLE READ级别下，总是读取**事务开始时的那份**快照数据。    

也就是说在READ COMMITTED 级别下，**每次读取都会创建一个新的ReadView**；REPEATABLE READ级别下，**ReadView在事务开启时创建，同一个事务中的读取都在同一个ReadView中**

### 一致性锁定读
一般，默认配置下，InnoDB引擎的事务隔离级别为REPEATABLE READ，采用一致性非锁定读。但某些特殊情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。这时就需要数据库支持加锁语句。  
* X锁：SELECT ······ FOR UPDATE

* S锁：SELECT ······ LOCK IN SHARE MODE
  对于一致性非锁定读，即使读取的行已经执行FOR UPDATE加了X锁，也是可以进行读取的。  

**手动加锁必须在一个事务中，当事务提交了，锁也就释放了**。所以在使用时，务必加上BEGIN，START TRANSACTION，或者SET AUTOCOMMIT = 0  

### 行锁的三种算法
* Record lock：单个行记录上的锁，通过索引来锁定，如果表没有建立索引，则采用一个隐式的索引来锁行
* Gap lock：间隙锁，锁定一个范围，不包括记录本身
* Next-key lock：record+gap 锁定一个范围，包含记录本身。InnoDB对于行的查询都是这种算法，目的是**解决幻读**。当查询的索引含有唯一属性，会降级为Record Lock，仅锁住索引本身，而不是范围。  
### 解决Phantom Problem幻读问题
幻读是指，**在同一事务下，连续执行两次同样的SQL可能导致不同的结果，第二次执行可能返回之前不存在的行**。  

在默认的REPEATABLE READ可重复读级别下，**InnoDB使用Next-Key Locking算法和MVCC来避免幻读**。  

例如某张表有2，6，9，11四条数据，此时要查询a=6的数据，事务不提交，在另一个事务中插入a=7，并提交该事务。在会发生幻读的READ COMMITED级别下，可以插入成功，并且如果此时查询大于6的数据可以查到刚插入的7，则事务之间没有隔离性；在REPEATABLE READ级别下，Next-Key算法会锁住(2,6) 6 (6,9)，则插入7的事务会阻塞。

### 什么时候会加行级锁

> https://zhuanlan.zhihu.com/p/52678870  
>
> https://www.cnblogs.com/rjzheng/p/9950951.html 这个人数据库写的不错，可以多看

mysql的**行锁是基于索引加载的**，所以行锁是要加在索引响应的行上，即命中索引  

注意：Insert时，如果找到了冲突元素，则加Next Key Lock；如果没找到冲突元素，则只会加隐式锁，隐式锁不是锁，只会在其他事务竞争锁的时候才生成锁结构。

### 什么时候会加表级锁

1. 当涉及到需要加锁的操作时，没有使用到索引，需要全表扫描，此时会给每个元素加行锁，以及所有间隙的间隙锁(跟表锁差不多)  

2. 当涉及到数据崩溃恢复时用到
3. 手动加表锁，尽量避免使用

```
LOCK TABLES t READ;
LOCK TABLES t WRITE;
```

4. 当插入数据时，如果主键添加了AUTO_INCREMENT，则会加表级的AUTO_INC锁，有两种实现方式：

   * 插入数据全过程中，加表级的AUTO_INC锁，直到INSERT语句执行结束
   * 只在获取AUTO_INCREMENT表列的值时加轻量级锁
   * 以上两种情况使用哪种，依据InnoDB中innodb_autoinc_lock_mode的配置来选择，可以配置其中一种，或者混合模式（插入记录的数量确定时采用轻量级锁，不确定时采用AUTO_INC锁）。**默认采用AUTO_INC锁**。

   

## 锁的问题
**对于事务的隔离性，锁定机制会带来三种问题**

### 脏读
脏数据是指事务对缓冲池中的行记录进行了修改，并且还没有被提交。如果一个事务读到了其他事务中**未提交的数据**，显然违背了事务的隔离性。这就是脏读。  

在READ UNCOMMITED级别下，脏读问题会发生。  

### 不可重复读
不可重复读是指在一个事务内，多次读取同一数据的集合。在这个事务还没有结束前，另一个事务也访问该同一数据集合，并做了一些DML操作。第一个事务第二次读统一数据的集合，由于第二个事务的修改，第一个事务两次读到的数据不一样，即同一事务内多次读到的数据不一样的情况，叫做 不可重复读。  
* **不可重复读和脏读的区别是：不可重复读，读到了已经提交的数据；脏读读到了未提交的数据。**
* **不可重复读和幻读的区别是：不可重复读注重数据被修改；幻读注重数据被增删。**  
* 在InnoDB中，和幻读一样，Next-Key Locking算法解决了不可重复读
### 丢失更新
丢失更新是另一个锁导致的，**简单来说就是一个事务的更新操作会被另一个事务的更新操作所覆盖**，从而导致数据不一致。例如：
1. 事务T1将行记录r更改为v1，T1未提交
2. 同时，T2将r更改为v2，T2未提交
3. T1提交
4. T2提交
事实上，MySQL中任何隔离级别下，**都不会导致丢失更新**。因为任何对于行的DML，需要对行或者更粗粒度的对象加锁，则步骤2根本不能在T1未提交之前发生。
## 事务
数据库引入事务的目的：**事务会把数据库从一种一致状态转换为另一种一致状态**。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。  

事务是访问并更新数据库中各种数据项的一个基本单元。  

### ACID
InnoDB存储引擎中的事务完全符合ACID的特性：
* **原子性** Atomicity：要么都做，要么都不做，不可分割
* **一致性** Consistency：事务将数据库从一种一致的状态转化为另一种一致的状态
* **隔离性** Isolation：并发控制、可串行化。每个读写事务对其他事务的操作对象能相互分离。粒度锁实现
* **持久性** Durability：事务一旦提交成功，其结果就是永久性的。保证高可靠性，而不是高可用性。
### 事务的隔离级别从低到高
* READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能**会导致脏读、幻读或不可重复读。**
* READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止**脏读，但是幻读或不可重复读仍有可能发生**。
* REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以**阻止脏读和不可重复读，但幻读仍有可能发生**。**InnoDB默认的隔离级别**，事实上，**对于InnoDB来说，由于间隙锁的实现，在此隔离级别下幻读也被避免了** 
* SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以**防止脏读、不可重复读以及幻读**。
### 事务的实现
隔离性由锁来实现；原子性、一致性、持久性通过redo log重做日志和undo log来实现；redo log保证原子性和持久性；undo log 保证一致性  
#### 三种日志
* redo log实现**持久性**。redo log记载着在某个页上做了什么修改，提交时写入redo log buffer，buffer什么时候刷盘有配置供选择。redo log顺序写入，顺序IO写入的速度很快，且记载的是物理变化，文件体积很小，恢复速度很快。帮助实现持久性。  
* undo log帮助**事务回滚以及MVCC。数据修改**也记录在undo log中，存储逻辑日志，他会记录一条与数据库所作操作**相反**的操作日志，另外还记录着数据修改之前的版本，可以实现MVCC。帮助实现原子性和隔离性。  
* **binlog记录了数据库表结构和表数据的变更，可以简单理解为存储着每条变更的SQL语句**，用来进行POINT-IN-TIME的恢复以及主从复制环境的建立（事务中用不到），简单来说就是用来复制和恢复数据。例如数据库中的数据修改了，但是用户查询是走ES的，那么ES也需要同步到数据库中的修改，我们就会监听binlog的变更并同步到ES。用于备份和主从同步。    
#### 实现持久性
InnoDB通过 Force Log At Commot 实现事务的持久性，即当事务提交时，**必须先将事务的所有日志写入 redo log 进行持久化**，待事务的Commit操作完成才算完成。这里**重做日志指 redo log 和 undo log**。  
#### 实现一致性
在对数据库进行修改时，存储引擎不但会产生redo，还会产生undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLL BACK请求回滚，就可以**利用这些undo信息将数据回滚到修改之前的样子**。  

另外，**为了保证redo log 和 undo log的一致性，MySQL采用了2XA两阶段提交**。  

#### 实现隔离性

隔离性是为了并发安全性，**使用锁和MVCC**，MVCC的实现使用了undo log。前面讲了，读写分离的思想。
#### 实现原子性
也是undo log，实现回滚
### 分布式事务
#### 分布式事务
分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中，要求参与在其中的事务要么都提交，要么都回滚。在使用分布式事务时，InnoDB的事务隔离级别必须设置成SERIALIZABLE  

XA事务允许不同数据库之间的分布式事务，由一个资源管理器，一个事务管理器和一个应用程序组成。  

MySQL分布式事务使用**两段式提交**：第一阶段，所有节点开始准备，并告诉事务管理器他们准备好了；第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT，如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。

#### 内部XA事务
在MySQL内部，也存在分布式事务。  

最常见的是binlog和InnoDB引擎之间，事务提交时先写redo log，并把redo log标志为prepare，然后写binlog，写入成功后调用InnoDB将redo log commit。对这两个操作也要求是原子的，若binlog先写了，然后发生了宕机，重做日志没有写，则slave可能会受到master传过去的binlog并执行，导致主从不一致。  

为了解决这种问题，MySQL在binlog和InnoDB存储引擎之间采用XA事务。



