# 分布式锁
## 前言
在多线程环境下，由于上下文的切换，数据可能出现不一致的情况或者数据被污染，我们需要保证数据安全，所以想到了加锁。  

所谓的加锁机制呢，就是当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。  

**为分布式应用多个节点对共享资源的排他式访问而设定的锁就是分布式锁，其实就是保证共享资源某一时刻只能被某台机器JVM进程下某个线程访问。**分布式锁可以基于很多种方式实现，数据库锁、ZooKeeper、Redis...不管哪种方式，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。

## 基于Zookeeper的分布式锁
### ZK是什么
Zookeeper是一个数据库，文件存储系统，并且有监听通知机制（观察者模式）  
它的主要应用场景有以下几个：

* 服务注册与订阅（共用节点）
* 分布式通知（监听znode）
* 服务命名（znode特性）
* 数据订阅、发布（watcher）
* 分布式锁（临时节点）
### Zookeeper是文件存储系统，那他存了什么？
**节点**，节点类型：

* 持久节点：一旦创建就会一直存在，即使Zookeeper集群宕机也会存在，直到其被删除
* 临时节点：临时节点的生命周期是与客户端会话绑定的，**会话消失则节点消失**。并且，**临时节点只能做叶子节点**，不能创建子节点。
* 顺序节点：有持久的和临时的。会在节点后面加一个数字后缀，并且是有序的。例如生成的有序节点为/lock/node-0000000000，那它的下一个有序节点就是/lock/node-0000000001。  

ZooKeeper就是基于**临时顺序节点去实现分布式锁的**  

### 监听器 Watcher
事件监听器。ZK允许用户在指定节点上注册一些Watcher，并且在特定事件出发的时候，将事件通过监听器通知到感兴趣的客户端  

###  zk创建分布式锁
zk节点具有**唯一性**，让并发的线程先去加锁时创建同样的节点，创建成功的第一个返回true，他就可以继续下面的并发操作。而后续的节点全部都会创建节点失败，也就是加锁失败。  

### 释放锁
删除节点即释放锁，然后再通知其他线程过来加锁。  

没有获取到锁的进程有两种等待加锁的方式：

1. 利用死循环，不断尝试加锁，直到成功，**伪装一个其他线程阻塞的效果**。  
2. 没有加锁成功的进程，就**向这个锁节点注册一个监听器Watcher**，监听这个锁的释放。当这个锁被释放了，就可以调用回调函数重新获取锁。  

### 共享锁和独占锁同时实现
利用**有序节点**的特性。  

如果是读请求要获取共享锁，判断**如果当前没有比自己更小的节点，或者比自己更小的节点都是读请求**，那么可以获取到读锁；如果当前比自己小的节点中有写请求，则无法获取到读锁。  

如果写请求要获取独占锁，若**没有比自己更小的节点**，表示可以获取到写锁；如果**有比自己更小的节点，无论是读还是写操作，都无法获取到写锁**。  

### 避免死锁
加锁成功后，机器宕机了，节点是不是就不能删除了？  

**利用临时节点，客户端连接已断开，或者临时节点超时了，临时节点就会自动删除，别的服务就可以监听到节点的变化。**    

### 羊群效应
监听机制会导致一个问题，所有服务都去监听一个节点。假如服务特别多，**节点的释放也会通知所有服务器**，这对服务器是很大的一个挑战，一个释放的消息，就好像一个牧羊犬进入了羊群，大家都四散而开，随时可能干掉机器，会占用服务资源，网络带宽等等。这就是羊群效应  

**利用临时顺序节点**，让**读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点**，这样当锁被释放时，只会有一个节点被唤醒，不会产生羊群效应  

### 缺点
* ZK**性能**没有Redis那么高，因为每次创建锁和释放锁都要动态创建、销毁瞬时节点来实现锁功能  
* ZK中创建和删除节点只能通过Leader服务器来执行，然后同步到Follower机器上
* 使用Zookeeper也有可能带来并发问题，只是并不常见而已。由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。这时候就有两个服务认为自己获取到了锁。
	但这个问题不常见，是因为ZK有重试机制，一旦ZK集群检测不到客户端的心跳，就会重试。  
* Redis分布式锁是一个更好的实现。  

## 基于Redis的分布式锁
两个命令
```
SETNX key value
```
如果set成功，则表示加锁成功，返回1；key已经存在了则返回0  
```
SETEX key seconds value
```
key**生存时间**设为seconds，如果key存在，setex命令将覆写旧值。setex是一个**原子性**操作。  

这两个命令是实现分布式锁的关键。  

### setex
设置一个过期时间，就算持锁线程挂了，也会在失效时间到达时释放锁。  

### 加锁
```
SET KEY VALUE [NX|XX] [EX seconds] [PX milliseconds] 
```
* random_value 是客户端生成的唯一的字符串。
* NX（Not Exist） 代表只在键不存在时，才对键进行设置操作。
* PX 5000 设置键的过期时间为5000毫秒。
* PX也可以换成EX，设置过期时间，单位是秒  

循环加锁，加锁失败就睡眠一段时间，然后再检查一下。  

Redis server是分步去设置key值和过期时间，但Redis是单线程处理命令的，Redis执行这段函数的过程中，不可能有精力去执行其他函数，所以，就算是分成多个个动作去执行，也**不影响命令的原子性**。  

这里要注意一定不要把设置key和过期时间分成SETNX和EXPIRE两个命令执行，由于这是两条Redis命令，不具有原子性，如果在 NX 之后程序突然崩溃，导致锁没有设置过期时间，那么将会发生死锁。  

另外要注意加锁时时间不能过短，过短会导致线程没执行完，锁就自动释放掉了，**这时需要一个后台线程自动给锁续命**，每1/3超时时间检查一下线程是否执行完毕，并重置超时时间。

### 解锁

解锁时操作有误可能出现的两种错误：

* key直接作为解锁依据，直接del key。可能发生A的锁被B解锁了
* 把客户端标识存在value中，但判断时两次判断了。因为不是原子性判断的，所以可能发生A判断成功之后key刚好过期，然后B获得了锁，接着A解锁时解了B的锁。

解决方案：

1. UUID/requestId，拼装作为锁的Key，或者存在value中，**避免A加的锁被B解了**。  

2. **解锁利用LUA的原子性**，写一段脚本，判断目前加锁的Key和我们的参数是否相等，如果是就删除key，返回1，否则返回0  

### 可重入锁
UUID比较相同，则可重入。  

* 方案一： setex value中存储锁的重入次数，如果锁存在，且key中的UUID跟本线程的UUID一样，那么让value中存储的重入次数增加1  

* 方案二：利用哈希表<客户端ID+线程ID，value重入次数>

### Redis发生单点故障怎么办 ——Red Lock
单点故障会导致Redis分布式锁失效，所以使用多个Redis实例来实现分布式锁。多实例模式下，Redis设计了 Red Lock 算法来实现获取分布式锁的过程。  

1. **尝试从 N 个互相独立 Redis 实例获取锁**；
2. 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
3. 如果获取锁失败，到每个已经获取到锁的实例上释放锁


## 基于MySQL的分布式锁
获得锁：向表中插入一条记录，**唯一索引**可以保证该记录制备插入了一次，那么就可以用这个记录判断是否处于锁定状态。  

删除锁：删除这条记录  

存在以下问题：  
* **锁没有失效时间**，如果解锁失败，其他进程就无法再获取该锁
* 只能是**非阻塞锁**，插入失败就直接报错了，无法重试
* **不可重入**，已经获得锁的进程无法重新获取锁
