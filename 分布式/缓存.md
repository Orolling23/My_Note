# 缓存

### 博客记录

https://zhuanlan.zhihu.com/p/261413349  

https://mp.weixin.qq.com/s/6J2K2k4Db_20eGU6xGYVTw  

https://github.com/AobingJava/JavaFamily  

https://github.com/Dikea/awesome-job#Java  

## 缓存雪崩
目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。  

举个简单的例子：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是**数据库立马又被新的流量给打死了**。这就是我理解的缓存雪崩。  

**同一时间大面积失效**，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果打挂的是一个用户服务的库，那其他依赖他的库所有的接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你能重启的时候，用户早就睡觉去了，并且对你的产品失去了信心，什么垃圾产品。    

雪崩总结起来就是**Redis缓存由于某些原因（大批Key同时超时，或者Redis挂了）大面积失效，所有的请求到达存储层，导致存储层访问量暴增最终导致级联宕机**  

### 解决方案
1. 处理缓存雪崩简单，在批量往Redis存数据的时候，**把每个Key的失效时间都加个随机值就好了**，这样可以**保证数据不会在同一时间大面积失效**，我相信，Redis这点流量还是顶得住的。  
2. **如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免单点故障导致全部失效的问题**
3. **设置热点数据永远不过期，有更新操作就更新缓存就好了**（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间）
4. **如果是Redis宕机引起的雪崩，则保证Redis的高可用**，高可用的保证有以下几点：
   * 事前：主从 + 哨兵，redis cluster，避免全盘崩溃
   * 事中：本地ehcache缓存 + hystrix 限流&降级，避免MySQL被打死（https://www.cnblogs.com/myseries/p/11370109.html）
   * 事后：redis持久化，一旦重启，立刻从磁盘上加载数据，快速恢复缓存
## 缓存穿透/击穿
**缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求**，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，**攻击会导致数据库压力过大，严重会击垮数据库。**  

### 缓存穿透解决方案
1. 缓存穿透我会在**接口层增加校验**，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
    **不相信调用你的人，你不知道他会传什么参数给你。**  

  比如接口是分页查询的，但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？在你双十一当天就调你这个接口会发生什么，就不用我说了吧。  

2. 缓存取不到的数据，在数据库中也没有取到，可以**将存储层查不到的数据对应的空结果写入缓存层**

   缓存空数据会两个问题：(1)缓存许多空值，会占用更多内存空间（如果是攻击，会导致**内存溢出**）

   (2)如果存储层添加了这个之前查不到的数据，会导致缓存层和存储层数据不一致。要在添加时及时更新缓存层

3. **网关层Nginx**有配置项，可以让运维对单个IP每秒访问次数**超出阈值的IP都拉黑**。

4. **布隆过滤器**，利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

## 缓存击穿

缓存击穿，跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个*Key在失效的瞬间*，持续的大并发就穿破缓存，直接请求数据库**，就像在一个完好无损的桶上凿开了一个洞。

### 缓存击穿解决方案

根据不同场景采用不同的解决方式：

* 若缓存的数据是基本不会发生更新的，**则设置热点数据永不过期**

* 若数据更新不频繁，且缓存刷新流程耗时较少，**则采用缓存失效重新取数据时，加互斥锁，保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。**
* 若数据更新频繁或者缓存刷新的流程耗时较长，**则可以利用定时线程在缓存过期前主动重新构建缓存，或者延后缓存的过期时间**

## 无底洞问题

**当数据量越来越多，Redis水平扩容做的越来越大，性能不但没有好转，反而下降了。这种现象被称为缓存的“无底洞”现象**  

无底洞现象出现的原因是，由于采用哈希虚拟槽将key映射到各个节点，造成key的分布与业务无关。但是由于数据量和访问量的持续增加，有需要大量节点做水平扩容，导致键值分配到更多节点上。此时设计批量操作时，往往会需要从多个不同的节点取数据，相比单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次的网络时间。  

所以总结问题如下：

1. 客户端一次批量操作涉及多次网络操作，网络耗时增大
2. 网络连接数变多，对单节点的性能也有一定影响

#### 无底洞现象的解决方案

1. 串行命令：mget无法一次性获取，则逐次执行n条get命令。这种方法性能不是最优的，但是实现起来最容易
2. 串行IO：CRC16计算散列值，再对16383取余数就算出slot值，Smrt客户端会保存slot和节点的对应关系。有了对应关系就可以对key进行归档，得到每个节点上key的子列表，然后分别对每个节点mget。这种方法比第一种性能高，如果节点特别多，还是会有性能问题
3. 并行IO：将方案2的最后一步改为多线程执行
4. **hash_tag**：利用Redis Cluster的hash_tag功能，将多个有相关性的key强制分配到一个节点上

## 热点Key重建

开发人员使用“缓存 + 过期时间”既可以加速数据读写，有保证数据定时更新，这种模式满足大多数需求，但是两个问题如果同时出现，则会对应用造成致命伤害：

1. 当前key是一个热点key，并发非常大
2. 重建缓存不能在短时间内完成，可能是一个复杂SQL或者依赖多次IO

**那么在缓存失效的瞬间，大量缓存进到应用来重建缓存，造成后端负载过大，甚至应用崩溃**  



### 热点Key重建的优化方案

1. **互斥锁**：只允许一个线程重建缓存，其他线程等待缓存重建完毕，直接读取缓存即可

可以利用Redis的setnx互斥来加锁。会存在死锁或者线程池阻塞的风险，但一致性比较好

2. **永不过期**：热点数据永不过期，但会出现数据不一致的情况



## Redis高可用
一般避免以上情况发生我们从三个时间段去分析下：  

事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。  

事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL被打死。  

事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。  

