## 乐观锁和悲观锁

* 悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）  

* 乐观锁，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量

### 实现乐观锁的两种机制

1. 版本号机制：解决ABA问题
2. CAS算法：compare and swap，著名的**无锁算法**。需要实现为一个**原子操作**

### 乐观锁的问题

#### 1. ABA问题

A修改为C之后，验证原本数据库中的数据还是A，则表明没有被其他线程修改过。但可能是被其他线程修改成B之后又修改成了A，数据已经变了。这就是ABA问题  

JDK 1.5 以后的 **AtomicStampedReference 类**就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且**当前标志是否等于预期标志**，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。  

另外自己实现的话可以添加一个每次修改递增Version字段作为是否修改的标志

#### 2. 循环时间长开销大

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。并发量大的时候会发生。  

#### 3. 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。  

但是从 JDK 1.5开始，**提供了AtomicReference类来保证引用对象之间的原子性**，你可以把**多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作**。  

### CAS和synchronized的使用场景

**简单来说，CAS适用于读多，写比较少的情况下，冲突一般较少。synchronized适用于写比较多的情况下，冲突一般较多。**  

1. 对于资源竞争较少，冲突较少的情况，使用**synchronized进行线程阻塞和唤醒切换，以及用户态内核态之间的切换操作浪费CPU资源**；而**CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能**。
2. 对于资源竞争严重的情况，**CAS自旋的概率较大，会浪费更多的CPU资源**，效率低于synchronized。

其实现在synchronized经过各种优化之后，性能已经很高了，在线程冲突较少的情况，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。  