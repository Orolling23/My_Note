# Java 线程池

## 线程池的作用和场景

池化设计是一种非常常见的思想，**预设系统资源，并且重用系统资源，以达到抵消每次获取资源的消耗，比如创建线程的开销，并且更方便的管理资源**。  

线程池的配置有七个参数，分别看一看配置时需要注意那些地方。  

## 核心池大小

根据任务是**CPU密集型**还是**IO密集型** 

**CPU密集型：corePoolSize = CPU核数 + 1**

**IO密集型：corePoolSize = CPU核数 \* 2**

## 最大池大小

- 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。
- 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。

大小设置需要结合任务的性质、场景、阻塞队列来判断。

* `maxPoolSize` 最大线程数在生产环境上我们可以设置成`corePoolSize`一样，这样可以减少在处理过程中创建线程的开销。
* 如果业务时延需求高，也可以设置成两倍core，并且结合一个有界阻塞队列。

## 拒绝策略

>  https://cloud.tencent.com/developer/article/1520860  

拒绝策略触发的时机是阻塞队列满了，并且也不能创建新线程了。  

JDK内置四种拒绝策略。  

#### CallerRunsPolicy 调用者运行

交由提交任务的当前线程来处理。  

适用于**不允许失败的，对性能要求不高的，并发量较小的场景下使用。**由于是调用者执行，可能会阻塞后续的任务，性能会受一定影响，但不会发生丢失。  

#### AbortPolicy 中止策略

触发时，直接抛出拒绝执行的异常  

使用时要注意，务必正确处理抛出的异常，记录日志等。可以把异常抛到顶层处理，然后让RPC去做负载均衡。

#### DiscardPolicy 丢弃策略

直接丢弃，不触发任何操作  

使用场景是，任务无关紧要，丢了也没关系。基本上没有场景会允许使用这个策略。  

#### DiscardOldestPolicy 弃老策略

弹出队列头部最老的元素，并且执行当前元素  

使用场景是，发布具有时效性的消息时，新的消息已经来了，老的还没有发布出去。因为新的来了，则老的丧失了**时效性**，应该丢弃。  

* 注：如果是高并发，不可丢的场景，配参数解决不掉的。加机器加配置吧。

## 阻塞队列

可选择的队列有

* 无界队列 `LinkedBlockingQueue`，默认无界，可选有界。
* 有界队列 `ArrayBlockingQueue`
* 同步移交队列 `SynchronousQueue`

一般情况下选择有界队列，避免堆溢出。  

有界队列的capacity要根据业务任务能接受等待的最大时延来做决定。比如能接受在线程池中等待两秒，单个任务执行时间100ms，核心线程数是2，在配置max = core时，不会创建新线程，则可以配置有界队列大小是`(2s/0.1s)/2 = 10`。如果max线程数配置大一些，那么可以将有界队列减小一点也没关系

## 线程工厂





## 存活时间

